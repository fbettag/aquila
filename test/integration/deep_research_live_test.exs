defmodule Aquila.DeepResearchLiveTest do
  use ExUnit.Case, async: false
  use Aquila.Cassette

  @tag timeout: 480_000
  test "streams deep research and returns final report" do
    aquila_cassette "deep_research/stream-basic" do
      sink = Aquila.Sink.collector(self())

      {:ok, ref} =
        Aquila.deep_research_stream(
          [
            %{
              role: :user,
              content:
                "Provide a very short overview (max 3 bullet points) of the two most recent NASA Mars mission milestones."
            }
          ],
          sink: sink,
          timeout: 240_000,
          reasoning: %{effort: "medium"}
        )

      {:ok, response} = Aquila.await_stream(ref, 480_000)

      # Collect streaming events from mailbox (sent by collector sink)
      research_events = collect_research_events_from_mailbox(ref)

      # Validate basic response structure
      assert response.text != ""
      assert is_binary(response.meta[:model])

      # Validate deep research events were emitted during streaming
      assert length(research_events) > 0, "Expected deep research events during streaming"

      # Verify web search activity (key feature of deep research)
      web_search_events =
        Enum.filter(research_events, fn
          {:aquila_event, %{"payload" => %{"source" => "deep_research", "event" => event}}, ^ref} ->
            String.contains?(event, "web_search_call")

          _ ->
            false
        end)

      assert length(web_search_events) > 0,
             "Expected web search events (deep research should perform searches)"

      # Verify reasoning tokens were used (validates reasoning effort parameter)
      reasoning_tokens =
        response.meta[:usage]["output_tokens_details"]["reasoning_tokens"]

      assert is_integer(reasoning_tokens) and reasoning_tokens > 0,
             "Expected reasoning tokens to be consumed (got: #{inspect(reasoning_tokens)})"

      # Validate response quality - should contain substantive content
      # (flexible check that works with different API responses)
      word_count = response.text |> String.split() |> length()
      assert word_count > 20, "Expected substantive response (got #{word_count} words)"

      # Drain any remaining messages generated by the sink to keep the test mailbox clean
      flush_stream_messages(ref)
    end
  end

  defp collect_research_events_from_mailbox(ref, events \\ []) do
    receive do
      {:aquila_event, payload, ^ref} = msg when is_map(payload) ->
        if deep_research_payload?(payload) do
          collect_research_events_from_mailbox(ref, [msg | events])
        else
          collect_research_events_from_mailbox(ref, events)
        end

      {:aquila_chunk, _chunk, ^ref} ->
        collect_research_events_from_mailbox(ref, events)

      {:aquila_tool_call, _state, _meta, ^ref} ->
        collect_research_events_from_mailbox(ref, events)

      {:aquila_done, _text, _meta, ^ref} ->
        collect_research_events_from_mailbox(ref, events)

      {:aquila_error, _reason, ^ref} ->
        collect_research_events_from_mailbox(ref, events)

      {:aquila_event, _other_event, ^ref} ->
        collect_research_events_from_mailbox(ref, events)
    after
      0 -> Enum.reverse(events)
    end
  end

  defp deep_research_payload?(payload) do
    source =
      get_in_payload(payload, ["payload", "source"]) ||
        get_in_payload(payload, [:payload, :source]) ||
        get_in_payload(payload, ["source"]) ||
        get_in_payload(payload, [:source])

    case source do
      value when is_atom(value) -> value == :deep_research
      value when is_binary(value) -> value == "deep_research"
      _ -> false
    end
  end

  defp get_in_payload(value, []), do: value

  defp get_in_payload(payload, [key | rest]) when is_map(payload) do
    cond do
      Map.has_key?(payload, key) ->
        get_in_payload(Map.get(payload, key), rest)

      is_atom(key) and Map.has_key?(payload, Atom.to_string(key)) ->
        get_in_payload(Map.get(payload, Atom.to_string(key)), rest)

      is_binary(key) and Map.has_key?(payload, String.to_atom(key)) ->
        get_in_payload(Map.get(payload, String.to_atom(key)), rest)

      true ->
        nil
    end
  end

  defp get_in_payload(_other, _rest), do: nil

  defp flush_stream_messages(ref) do
    receive do
      {:aquila_chunk, _chunk, ^ref} -> flush_stream_messages(ref)
      {:aquila_event, _event, ^ref} -> flush_stream_messages(ref)
      {:aquila_tool_call, _state, _meta, ^ref} -> flush_stream_messages(ref)
      {:aquila_done, _text, _meta, ^ref} -> :ok
      {:aquila_error, _reason, ^ref} -> :ok
    after
      0 -> :ok
    end
  end
end
